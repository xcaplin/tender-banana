name: Fetch Daily Tender Data

on:
  schedule:
    # Run daily at 7am UTC (after data.gov.uk updates)
    - cron: '0 7 * * *'
  workflow_dispatch:  # Allow manual triggering
  push:
    branches:
      - main
    paths:
      - '.github/workflows/fetch-tenders.yml'

permissions:
  contents: write

jobs:
  fetch-tenders:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch and process tender data
        run: |
          # Create scripts directory if it doesn't exist
          mkdir -p scripts

          # Create the fetch script
          cat > scripts/fetch-ocds-data.js << 'SCRIPT_EOF'
          import https from 'https';
          import fs from 'fs';

          const S3_BASE = 'https://cdp-sirsi-production-cfs-471112843276.s3.eu-west-2.amazonaws.com/Harvester-new';
          const FIND_A_TENDER_API = 'https://www.find-tender.service.gov.uk/api/1.0/ocdsReleasePackages';

          // Fetch a URL and return text content
          function fetchURL(url, options = {}) {
            return new Promise((resolve, reject) => {
              const urlObj = new URL(url);
              const protocol = urlObj.protocol === 'https:' ? https : https;

              const fetchOptions = {
                hostname: urlObj.hostname,
                path: urlObj.pathname + urlObj.search,
                method: 'GET',
                headers: {
                  'User-Agent': 'Mozilla/5.0 (GitHub Actions)',
                  ...options.headers
                }
              };

              const req = protocol.request(fetchOptions, (res) => {
                if (res.statusCode !== 200) {
                  resolve(null);
                  return;
                }

                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
              });

              req.on('error', reject);
              req.end();
            });
          }

          // Parse CSV line
          function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result.map(v => v.replace(/^"|"$/g, '').trim());
          }

          // Parse CSV to tenders
          function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(l => l.trim());
            if (lines.length < 2) return [];

            const headers = parseCSVLine(lines[0]);
            const tenders = [];

            for (let i = 1; i < lines.length; i++) {
              try {
                const values = parseCSVLine(lines[i]);
                const row = {};
                headers.forEach((h, idx) => row[h] = values[idx] || '');

                const title = row['releases/0/tender/title'] || row['tender/title'] || '';
                if (!title) continue;

                // Validate deadline - must be a parseable date
                const deadlineStr = row['releases/0/tender/tenderPeriod/endDate'] || row['tender/tenderPeriod/endDate'] || '';
                const deadline = deadlineStr ? new Date(deadlineStr) : null;
                if (deadlineStr && (!deadline || isNaN(deadline.getTime()))) {
                  // Skip records with invalid deadline format
                  continue;
                }

                // Skip records that have no deadline AND no value (likely internal records/subcontracts)
                const value = parseFloat(row['releases/0/tender/value/amount'] || row['tender/value/amount'] || 0);
                if (!deadlineStr && value === 0) {
                  continue;
                }

                // Require at least some buyer information
                const buyer = row['releases/0/buyer/name'] || row['buyer/name'] || '';
                if (!buyer) continue;

                const tender = {
                  id: row['ocid'] || `tender-${i}`,
                  title: title,
                  organization: buyer,
                  value: value,
                  deadline: deadlineStr,
                  summary: (row['releases/0/tender/description'] || row['tender/description'] || '').substring(0, 200),
                  detailedDescription: row['releases/0/tender/description'] || row['tender/description'] || '',
                  region: row['releases/0/buyer/address/region'] || row['buyer/address/region'] || '',
                  url: `https://www.contractsfinder.service.gov.uk/notice/${row['ocid']}`,
                  status: 'new',
                  categories: [],
                  sirona_fit: null,
                  source: 'Contracts Finder'
                };

                tenders.push(tender);
              } catch (e) {
                // Skip invalid rows
              }
            }

            return tenders;
          }

          // Flatten OCDS JSON to tender objects (for Find a Tender API response)
          function flattenOCDSRelease(ocid, release) {
            const tender = {};

            // Extract tender information
            const tenderData = release.tender || {};
            tender.title = tenderData.title || '';
            tender.description = tenderData.description || '';
            tender.value = tenderData.value?.amount || 0;
            tender.deadline = tenderData.tenderPeriod?.endDate || '';

            // Extract buyer information
            const buyerData = release.buyer || {};
            tender.organization = buyerData.name || 'Unknown';
            tender.region = buyerData.address?.region || '';

            return {
              id: ocid,
              title: tender.title,
              organization: tender.organization,
              value: tender.value,
              deadline: tender.deadline,
              summary: (tender.description || '').substring(0, 200),
              detailedDescription: tender.description || '',
              region: tender.region,
              url: `https://www.find-tender.service.gov.uk/notice/${ocid}`,
              status: 'new',
              categories: [],
              sirona_fit: null,
              source: 'Find a Tender'
            };
          }

          // Fetch and process Find a Tender API data with pagination
          async function fetchFindATender() {
            console.log('Fetching data from Find a Tender API...');
            const tenders = [];

            try {
              // Fetch tenders updated in the last 90 days, filtered to 'tender' stage (open opportunities)
              const today = new Date();
              const ninetyDaysAgo = new Date(today.getTime() - 90 * 24 * 60 * 60 * 1000);
              const updatedFrom = ninetyDaysAgo.toISOString();

              let cursor = null;
              let hasMore = true;
              let pageCount = 0;

              while (hasMore) {
                pageCount++;
                let apiUrl = `${FIND_A_TENDER_API}?updatedFrom=${encodeURIComponent(updatedFrom)}&stages=tender&limit=100`;
                if (cursor) {
                  apiUrl += `&cursor=${encodeURIComponent(cursor)}`;
                }

                console.log(`  Fetching page ${pageCount}...`);
                const response = await fetchURL(apiUrl);

                if (!response) {
                  console.log('  Find a Tender API returned no data');
                  break;
                }

                try {
                  const data = JSON.parse(response);

                  if (!data.data || !Array.isArray(data.data)) {
                    console.log('  Unexpected Find a Tender API response format');
                    break;
                  }

                  // Process each release package
                  for (const pkg of data.data) {
                    try {
                      if (pkg.releases && Array.isArray(pkg.releases)) {
                        for (const release of pkg.releases) {
                          const tender = flattenOCDSRelease(pkg.ocid, release);

                          // Apply same validation as Contracts Finder
                          if (!tender.title) continue;

                          const deadline = tender.deadline ? new Date(tender.deadline) : null;
                          if (tender.deadline && (!deadline || isNaN(deadline.getTime()))) {
                            continue;
                          }

                          if (!tender.deadline && tender.value === 0) {
                            continue;
                          }

                          if (!tender.organization) continue;

                          tenders.push(tender);
                        }
                      }
                    } catch (e) {
                      // Skip invalid records
                    }
                  }

                  console.log(`    Found ${data.data.length} release packages on this page`);

                  // Handle pagination
                  if (data.links && data.links.next) {
                    cursor = data.links.next;
                  } else {
                    hasMore = false;
                  }
                } catch (parseError) {
                  console.error('Error parsing Find a Tender response:', parseError.message);
                  break;
                }

                // Be respectful with API calls
                await new Promise(resolve => setTimeout(resolve, 500));
              }

              console.log(`  Total tenders from Find a Tender: ${tenders.length}`);
            } catch (error) {
              console.error('Error fetching Find a Tender data:', error.message);
            }

            return tenders;
          }

          // Deduplicate tenders by ocid, preferring Contracts Finder data
          function deduplicateTenders(tendersList) {
            const seen = new Map();

            // Process tenders, keeping first occurrence of each ocid
            for (const tender of tendersList) {
              if (!seen.has(tender.id)) {
                seen.set(tender.id, tender);
              }
            }

            return Array.from(seen.values());
          }

          // Main execution
          async function main() {
            console.log('=== Tender Data Fetch Started ===\n');

            let allTenders = [];
            const today = new Date();

            // 1. Fetch Contracts Finder data (last 30 days)
            console.log('1. Fetching Contracts Finder data...');
            for (let i = 0; i < 30; i++) {
              const date = new Date(today);
              date.setDate(date.getDate() - i);

              const year = date.getFullYear();
              const month = String(date.getMonth() + 1).padStart(2, '0');
              const day = String(date.getDate()).padStart(2, '0');

              const url = `${S3_BASE}/${year}-${month}/Contracts%20Finder%20OCDS%20${year}-${month}-${day}.csv`;

              console.log(`  Fetching ${year}-${month}-${day}...`);
              const csvText = await fetchURL(url);

              if (csvText) {
                const tenders = parseCSV(csvText);
                allTenders.push(...tenders);
                console.log(`    Found ${tenders.length} tenders`);
              }

              // Small delay to be nice to the server
              await new Promise(resolve => setTimeout(resolve, 100));
            }

            console.log(`\n  Contracts Finder total: ${allTenders.length} tenders\n`);

            // 2. Fetch Find a Tender data (updated in last 24 hours, stage=tender only)
            console.log('2. Fetching Find a Tender data...');
            const findATenderTenders = await fetchFindATender();
            console.log(`\n  Find a Tender total: ${findATenderTenders.length} tenders\n`);

            // 3. Combine datasets
            console.log('3. Combining and deduplicating...');
            allTenders.push(...findATenderTenders);
            const deduplicated = deduplicateTenders(allTenders);

            console.log(`  Total before deduplication: ${allTenders.length}`);
            console.log(`  Total after deduplication: ${deduplicated.length}`);
            console.log(`  Duplicates removed: ${allTenders.length - deduplicated.length}\n`);

            // 4. Log statistics
            const contractsFinderCount = deduplicated.filter(t => t.source === 'Contracts Finder').length;
            const findATenderCount = deduplicated.filter(t => t.source === 'Find a Tender').length;

            console.log('=== Dataset Summary ===');
            console.log(`Total tenders: ${deduplicated.length}`);
            console.log(`  - Contracts Finder: ${contractsFinderCount}`);
            console.log(`  - Find a Tender: ${findATenderCount}`);

            const withDeadlines = deduplicated.filter(t => t.deadline).length;
            const withoutDeadlines = deduplicated.filter(t => !t.deadline).length;
            console.log(`\nTenders with deadlines: ${withDeadlines}`);
            console.log(`Tenders without deadlines: ${withoutDeadlines}`);

            // 5. Write to file
            const output = {
              generated: new Date().toISOString(),
              count: deduplicated.length,
              sources: {
                contractsFinder: contractsFinderCount,
                findATender: findATenderCount
              },
              tenders: deduplicated
            };

            // Ensure public/data directory exists
            if (!fs.existsSync('public/data')) {
              fs.mkdirSync('public/data', { recursive: true });
            }

            fs.writeFileSync('public/data/live-tenders.json', JSON.stringify(output, null, 2));
            console.log('\nâœ“ Written to public/data/live-tenders.json');
          }

          main().catch(console.error);
          SCRIPT_EOF

          # Run the script
          node scripts/fetch-ocds-data.js

      - name: Commit and push if changed
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git add public/data/live-tenders.json
          git diff --quiet && git diff --staged --quiet || (git commit -m "Update tender data [automated]" && git pull --no-edit origin main && git push)
