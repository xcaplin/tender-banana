/**
 * Tender Fetcher Service - GitHub Actions Edition
 *
 * Reads tender data from JSON file generated daily by GitHub Actions.
 * GitHub Actions fetches OCDS CSV files server-side (no CORS issues)
 * and commits processed data to the repository.
 */

/**
 * Main function to fetch and process tenders
 * Reads from locally stored JSON file (updated daily by GitHub Actions)
 * Returns { tenders: [], totalCount: number }
 */
export async function fetchAndProcessTenders(searchParams) {
  console.log('Loading tender data from repository...')
  console.log('Search parameters:', searchParams)

  try {
    // Fetch the JSON file generated by GitHub Actions
    // Use import.meta.env.BASE_URL to respect the base path in vite.config.js
    const response = await fetch(`${import.meta.env.BASE_URL}data/live-tenders.json`)

    if (!response.ok) {
      throw new Error(`Failed to load tender data: ${response.status}`)
    }

    const data = await response.json()
    console.log(`Loaded ${data.count} tenders (generated: ${data.generated})`)

    // Enrich with placeholder AI data
    const enrichedTenders = data.tenders.map(tender => ({
      ...tender,
      sirona_fit: tender.sirona_fit || generatePlaceholderFit()
    }))

    // Apply client-side filters
    const filtered = applyFilters(enrichedTenders, searchParams)

    console.log(`After filtering: ${filtered.length} tenders`)

    return {
      tenders: filtered,
      totalCount: data.count
    }

  } catch (error) {
    console.error('Error loading tender data:', error)
    return { tenders: [], totalCount: 0 }
  }
}

/**
 * Apply client-side filters to tender list
 */
function applyFilters(tenders, searchParams) {
  let filtered = tenders

  console.log(`Applying filters to ${tenders.length} tenders...`)

  // Keywords filter
  if (searchParams.keywords?.trim()) {
    const kw = searchParams.keywords.toLowerCase().trim()
    filtered = filtered.filter(t =>
      t.title.toLowerCase().includes(kw) ||
      t.summary.toLowerCase().includes(kw) ||
      t.organization.toLowerCase().includes(kw) ||
      (t.detailedDescription && t.detailedDescription.toLowerCase().includes(kw))
    )
    console.log(`After keywords filter: ${filtered.length} tenders`)
  }

  // Location filter - searches across multiple fields for better regional coverage
  if (searchParams.location?.trim()) {
    const loc = searchParams.location.toLowerCase().trim()
    filtered = filtered.filter(t =>
      t.region.toLowerCase().includes(loc) ||
      t.organization.toLowerCase().includes(loc) ||
      t.title.toLowerCase().includes(loc) ||
      t.summary.toLowerCase().includes(loc) ||
      (t.detailedDescription && t.detailedDescription.toLowerCase().includes(loc))
    )
    console.log(`After location filter: ${filtered.length} tenders`)
  }

  // Value range filters
  if (searchParams.minValue) {
    const minVal = parseFloat(searchParams.minValue)
    filtered = filtered.filter(t => t.value >= minVal)
    console.log(`After min value filter: ${filtered.length} tenders`)
  }

  if (searchParams.maxValue) {
    const maxVal = parseFloat(searchParams.maxValue)
    filtered = filtered.filter(t => t.value <= maxVal)
    console.log(`After max value filter: ${filtered.length} tenders`)
  }

  // Date range filter (on deadline)
  if (searchParams.publishedFrom || searchParams.publishedTo) {
    filtered = filtered.filter(t => {
      if (!t.deadline) return false

      const deadline = new Date(t.deadline)
      const from = searchParams.publishedFrom ? new Date(searchParams.publishedFrom) : new Date('2000-01-01')
      const to = searchParams.publishedTo ? new Date(searchParams.publishedTo) : new Date('2100-01-01')

      return deadline >= from && deadline <= to
    })
    console.log(`After date filter: ${filtered.length} tenders`)
  }

  console.log(`Final filtered count: ${filtered.length} tenders`)
  return filtered
}

/**
 * Generate placeholder AI analysis data
 */
function generatePlaceholderFit() {
  return {
    alignment_score: Math.floor(Math.random() * 30) + 60, // 60-90%
    recommendation: getRandomRecommendation(),
    rationale: 'This tender requires AI analysis. Use the "Analyze This Tender" feature for detailed strategic fit assessment.',
    win_themes: [
      'Community-focused healthcare delivery',
      'Integrated care experience',
      'Local knowledge and presence'
    ],
    competitors: [
      'Local NHS Trusts',
      'Other community health providers',
      'National healthcare organizations'
    ],
    weak_spots: [
      'Competitive landscape to be assessed',
      'Strategic fit requires detailed analysis',
      'Resource requirements need review'
    ],
    categories: []
  }
}

/**
 * Get random recommendation for placeholder
 */
function getRandomRecommendation() {
  const recommendations = ['Strong Go', 'Conditional Go', 'Monitor', 'No Bid']
  const weights = [0.25, 0.35, 0.30, 0.10]

  const random = Math.random()
  let cumulative = 0

  for (let i = 0; i < recommendations.length; i++) {
    cumulative += weights[i]
    if (random < cumulative) {
      return recommendations[i]
    }
  }

  return 'Monitor'
}

/**
 * Enrich tender with AI analysis (placeholder stub)
 * Real AI analysis is done via Claude analyzer service
 */
export async function enrichTenderWithAI(tender) {
  return tender
}

// Export configuration
export const getConfig = () => ({
  DATA_SOURCE: 'GitHub Actions Daily Fetch',
  UPDATE_SCHEDULE: 'Daily at 7am UTC',
  COVERAGE: 'Last 30 days'
})
